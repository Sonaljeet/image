import json
import os
from urllib.parse import urlparse, parse_qs
import yaml


def extract_apis_from_har(har_file):
    """
    Parse HAR file and extract all unique APIs with redirects, referrers, and pagination params.
    """
    with open(har_file, "r", encoding="utf-8") as f:
        har_data = json.load(f)

    api_data = {}

    for entry in har_data["log"]["entries"]:
        req = entry["request"]
        resp = entry.get("response", {})
        url = req["url"]
        parsed = urlparse(url)

        domain = parsed.netloc
        path = parsed.path or "/"
        method = req["method"]
        query_params = list(parse_qs(parsed.query).keys())
        referrer = next((h["value"] for h in req["headers"] if h["name"].lower() == "referer"), None)
        redirect_to = None

        # detect redirect target if exists
        if 300 <= resp.get("status", 0) < 400:
            for header in resp.get("headers", []):
                if header["name"].lower() == "location":
                    redirect_to = header["value"]

        key = (domain, method, path)
        if key not in api_data:
            api_data[key] = {
                "domain": domain,
                "method": method,
                "path": path,
                "query_params": set(query_params),
                "request_bodies": [],
                "referrer": referrer,
                "redirect_to": redirect_to,
            }

        # Add request body if exists
        if req.get("postData", {}).get("text"):
            api_data[key]["request_bodies"].append(req["postData"]["text"])

        # Merge query params
        api_data[key]["query_params"].update(query_params)

        # Update redirect if found
        if redirect_to:
            api_data[key]["redirect_to"] = redirect_to

    # Auto-detect pagination parameters
    pagination_params = {"page", "limit", "offset", "per_page", "size"}
    for k, v in api_data.items():
        detected = set(p for p in v["query_params"] if p.lower() in pagination_params)
        if detected:
            v["pagination_params"] = detected

    return api_data


def generate_openapi(api_data, output_dir="output", prefix="extracted_api"):
    """
    Generate OpenAPI YAMLs from extracted API data.
    """
    os.makedirs(output_dir, exist_ok=True)
    openapi = {
        "openapi": "3.0.0",
        "info": {"title": "Extracted APIs", "version": "1.0.0"},
        "paths": {},
    }

    for (domain, method, path), data in api_data.items():
        op = {
            "summary": f"Auto-extracted {method.upper()} {path}",
            "parameters": [],
            "responses": {"200": {"description": "Successful response"}},
        }

        for qp in data["query_params"]:
            param = {
                "name": qp,
                "in": "query",
                "required": False,
                "schema": {"type": "string"},
            }
            if "pagination_params" in data and qp in data["pagination_params"]:
                param["description"] = "Pagination parameter"
                param["schema"]["type"] = "integer"
            op["parameters"].append(param)

        openapi["paths"].setdefault(path, {})[method.lower()] = op

    output_file = os.path.join(output_dir, f"{prefix}_combined.yaml")
    with open(output_file, "w", encoding="utf-8") as f:
        yaml.dump(openapi, f, sort_keys=False)
    print(f"âœ… OpenAPI generated: {output_file}")


def generate_karate_features(api_data, output_dir="output", prefix="extracted_api"):
    """
    Generate Karate feature files with redirect & pagination support.
    """
    os.makedirs(output_dir, exist_ok=True)
    combined_file = os.path.join(output_dir, f"{prefix}_combined.feature")

    with open(combined_file, "w", encoding="utf-8") as f_combined:
        f_combined.write("Feature: Extracted API Scenarios (auto-generated from HAR)\n\n")

        domains = {}
        for (domain, method, path), data in api_data.items():
            domains.setdefault(domain, []).append((method, path, data))

        for domain, apis in domains.items():
            f_combined.write(f"  # Domain: {domain}\n")
            f_combined.write("  Background:\n")
            f_combined.write(f"    * url 'https://{domain}'\n\n")

            domain_file = os.path.join(output_dir, f"{prefix}_{domain.replace(':', '_')}.feature")
            with open(domain_file, "w", encoding="utf-8") as f_domain:
                f_domain.write(f"Feature: API Scenarios for {domain}\n\n")
                f_domain.write("  Background:\n")
                f_domain.write(f"    * url 'https://{domain}'\n\n")

                for method, path, data in apis:
                    scenario = f"  Scenario: {method.upper()} {path}\n"
                    scenario += f"    # Method: {method.upper()}\n"
                    if data.get("referrer"):
                        scenario += f"    # Referrer: {data['referrer']}\n"
                    if data.get("redirect_to"):
                        scenario += f"    # Redirects to: {data['redirect_to']}\n"

                    scenario += f"    Given path '{path.strip('/')}'\n"

                    if data["query_params"]:
                        scenario += "    And params { " + ", ".join(
                            [f"{p}: '<value>'" for p in data["query_params"]]
                        ) + " }\n"

                    if data["request_bodies"]:
                        try:
                            sample = json.loads(data["request_bodies"][0])
                            pretty_body = json.dumps(sample, indent=4)
                            scenario += "    And request " + pretty_body.replace("\n", "\n    ") + "\n"
                        except Exception:
                            scenario += "    And request { }\n"

                    scenario += f"    When method {method.upper()}\n"
                    scenario += "    Then status 200\n"
                    scenario += "    And match response != null\n"

                    # Multi-hop redirect following (up to 3)
                    hops = []
                    next_redirect = data.get("redirect_to")
                    visited = set()
                    while next_redirect and len(hops) < 3 and next_redirect not in visited:
                        visited.add(next_redirect)
                        hops.append(next_redirect)
                        # Try to find next hop if it also exists in api_data
                        for (d2, m2, p2), v2 in api_data.items():
                            full_url = f"https://{d2}{p2}"
                            if full_url == next_redirect:
                                next_redirect = v2.get("redirect_to")
                                break
                        else:
                            next_redirect = None

                    for hop_url in hops:
                        parsed = urlparse(hop_url)
                        hop_path = parsed.path.strip("/")
                        scenario += "\n    # Follow redirect automatically\n"
                        scenario += f"    * def redirectUrl = responseHeaders['Location'][0] || '{hop_url}'\n"
                        scenario += f"    Given url redirectUrl\n"
                        scenario += "    When method GET\n"
                        scenario += "    Then status 200\n"
                        scenario += "    And match response != null\n"

                    scenario += "\n"

                    f_domain.write(scenario)
                    f_combined.write(scenario)

            print(f"âœ… Karate feature generated for {domain}: {domain_file}")

    print(f"âœ… Combined Karate feature generated: {combined_file}")


def main(har_file):
    output_dir = "output"
    prefix = "extracted_api"

    print(f"ðŸ” Parsing HAR: {har_file}")
    api_data = extract_apis_from_har(har_file)

    print(f"ðŸ“„ Generating OpenAPI YAMLs...")
    generate_openapi(api_data, output_dir, prefix)

    print(f"ðŸ¤– Generating Karate feature files...")
    generate_karate_features(api_data, output_dir, prefix)

    print("âœ… Done!")


if __name__ == "__main__":
    har_file = "C://Users//sonal//Downloads//google.har"  # replace with your HAR path
    main(har_file)
